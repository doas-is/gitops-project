"""
IaC Generator Agent

Receives: PolicyDecision + StrategyDecision
Produces: Terraform (.tf) + Ansible playbook (.yml) as strings

Never sees raw code. Operates on constraints + strategy only.
Output is written to an ephemeral in-memory dict; the Deployment
Agent picks it up and applies it, then everything is deleted.
"""
from __future__ import annotations

import logging
import time
from dataclasses import dataclass, field
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)


@dataclass
class IaCBundle:
    """All generated IaC files for one task."""
    task_id: str
    method: str                          # "declarative" | "imperative" | "hybrid"
    terraform_files: Dict[str, str]      # filename → content
    ansible_files: Dict[str, str]        # filename → content
    resource_list: List[str]
    constraints_applied: List[str]
    generated_at: float = field(default_factory=time.time)


class IaCGeneratorAgent:
    """
    Generates Terraform + Ansible from policy constraints and strategy.
    Input: PolicyDecision, StrategyDecision
    Output: IaCBundle (in-memory, never written to disk by this agent)
    """

    def generate(self, policy_decision, strategy_decision) -> IaCBundle:
        task_id = policy_decision.task_id
        constraints = [c.constraint_type for c in policy_decision.constraints]
        method = strategy_decision.method
        resources = strategy_decision.estimated_resources

        logger.info("Generating IaC for task=%s method=%s constraints=%s",
                    task_id, method, constraints)

        tf_files: Dict[str, str] = {}
        ans_files: Dict[str, str] = {}

        if method == "none":
            return IaCBundle(task_id=task_id, method="none",
                             terraform_files={}, ansible_files={},
                             resource_list=[], constraints_applied=constraints)

        # Always generate core infrastructure
        tf_files["main.tf"] = self._tf_main(task_id, constraints, resources)
        tf_files["variables.tf"] = self._tf_variables()
        tf_files["outputs.tf"] = self._tf_outputs()
        tf_files["nsg.tf"] = self._tf_nsg(constraints)

        if method in ("declarative", "hybrid"):
            ans_files["site.yml"] = self._ansible_site(task_id, constraints)
            ans_files["roles/hardening/tasks/main.yml"] = self._ansible_hardening(constraints)

        if method == "imperative":
            tf_files["deploy.sh"] = self._imperative_script(task_id, constraints)

        if "sandboxed_execution" in constraints:
            tf_files["container.tf"] = self._tf_container(task_id)
        if "monitoring_required" in constraints:
            tf_files["monitoring.tf"] = self._tf_monitoring(task_id)

        return IaCBundle(
            task_id=task_id,
            method=method,
            terraform_files=tf_files,
            ansible_files=ans_files,
            resource_list=resources,
            constraints_applied=constraints,
        )

    # ── Terraform templates ──────────────────────────────────────

    def _tf_main(self, task_id: str, constraints: List[str], resources: List[str]) -> str:
        isolation = "true" if "network_isolation" in constraints else "false"
        sandbox = "true" if "sandboxed_execution" in constraints else "false"
        return f'''# Generated by IaC Generator Agent
# Task: {task_id}
# DO NOT EDIT — auto-generated, ephemeral

terraform {{
  required_providers {{
    azurerm = {{
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }}
  }}
  backend "azurerm" {{
    resource_group_name  = var.state_resource_group
    storage_account_name = var.state_storage_account
    container_name       = "tfstate"
    key                  = "{task_id}.tfstate"
  }}
}}

provider "azurerm" {{
  features {{}}
  subscription_id = var.subscription_id
  tenant_id       = var.tenant_id
  client_id       = var.client_id
  client_secret   = var.client_secret
}}

resource "azurerm_resource_group" "main" {{
  name     = "rg-${{var.app_name}}-${{var.environment}}"
  location = var.location
  tags = {{
    task_id     = "{task_id}"
    managed_by  = "secure-analysis-platform"
    isolated    = "{isolation}"
    sandboxed   = "{sandbox}"
  }}
}}

resource "azurerm_virtual_network" "main" {{
  name                = "vnet-${{var.app_name}}"
  resource_group_name = azurerm_resource_group.main.name
  location            = azurerm_resource_group.main.location
  address_space       = ["10.0.0.0/16"]
}}

resource "azurerm_subnet" "app" {{
  name                 = "snet-app"
  resource_group_name  = azurerm_resource_group.main.name
  virtual_network_name = azurerm_virtual_network.main.name
  address_prefixes     = ["10.0.1.0/24"]
}}

resource "azurerm_subnet_network_security_group_association" "app" {{
  subnet_id                 = azurerm_subnet.app.id
  network_security_group_id = azurerm_network_security_group.app.id
}}
'''

    def _tf_nsg(self, constraints: List[str]) -> str:
        deny_all = "network_isolation" in constraints
        default_action = "Deny" if deny_all else "Allow"
        return f'''# NSG — Network Security Group
# network_isolation={deny_all}

resource "azurerm_network_security_group" "app" {{
  name                = "nsg-app"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name

  security_rule {{
    name                       = "AllowHTTPS"
    priority                   = 100
    direction                  = "Inbound"
    access                     = "Allow"
    protocol                   = "Tcp"
    source_port_range          = "*"
    destination_port_range     = "443"
    source_address_prefix      = var.allowed_cidr
    destination_address_prefix = "*"
  }}

  security_rule {{
    name                       = "AllowInternalMTLS"
    priority                   = 200
    direction                  = "Inbound"
    access                     = "Allow"
    protocol                   = "Tcp"
    source_port_range          = "*"
    destination_port_range     = "8443"
    source_address_prefix      = "10.0.0.0/16"
    destination_address_prefix = "*"
  }}

  security_rule {{
    name                       = "DenyAllInbound"
    priority                   = 4096
    direction                  = "Inbound"
    access                     = "{default_action}"
    protocol                   = "*"
    source_port_range          = "*"
    destination_port_range     = "*"
    source_address_prefix      = "*"
    destination_address_prefix = "*"
  }}

  security_rule {{
    name                       = "DenyAllOutbound"
    priority                   = 4096
    direction                  = "Outbound"
    access                     = "{default_action}"
    protocol                   = "*"
    source_port_range          = "*"
    destination_port_range     = "*"
    source_address_prefix      = "*"
    destination_address_prefix = "*"
  }}
}}
'''

    def _tf_variables(self) -> str:
        return '''variable "subscription_id" {}
variable "tenant_id" {}
variable "client_id" {}
variable "client_secret" { sensitive = true }
variable "location" { default = "eastus" }
variable "app_name" {}
variable "environment" { default = "prod" }
variable "app_image" {}
variable "allowed_cidr" { default = "0.0.0.0/0" }
variable "state_resource_group" {}
variable "state_storage_account" {}
'''

    def _tf_outputs(self) -> str:
        return '''output "resource_group_name" {
  value = azurerm_resource_group.main.name
}
output "vnet_id" {
  value = azurerm_virtual_network.main.id
}
'''

    def _tf_container(self, task_id: str) -> str:
        return f'''# Sandboxed container — task {task_id}
resource "azurerm_container_group" "app" {{
  name                = "aci-app"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
  os_type             = "Linux"
  restart_policy      = "Never"
  ip_address_type     = "Private"
  subnet_ids          = [azurerm_subnet.app.id]

  container {{
    name   = "app"
    image  = var.app_image
    cpu    = "0.5"
    memory = "1.5"

    security_context {{
      allow_privilege_escalation = false
      read_only_root_filesystem  = true
      run_as_non_root            = true
      run_as_user                = 1000
    }}
  }}
}}
'''

    def _tf_monitoring(self, task_id: str) -> str:
        return f'''# Monitoring — task {task_id}
resource "azurerm_log_analytics_workspace" "main" {{
  name                = "law-app"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
  sku                 = "PerGB2018"
  retention_in_days   = 30
}}

resource "azurerm_monitor_activity_log_alert" "security" {{
  name                = "alert-security"
  resource_group_name = azurerm_resource_group.main.name
  scopes              = [azurerm_resource_group.main.id]
  criteria {{
    category = "Security"
    level    = "Warning"
  }}
  action {{
    action_group_id = var.action_group_id
  }}
}}
'''

    # ── Ansible templates ────────────────────────────────────────

    def _ansible_site(self, task_id: str, constraints: List[str]) -> str:
        roles = ["common", "hardening"]
        if "monitoring_required" in constraints:
            roles.append("monitoring")
        roles_yaml = "\n    - ".join(roles)
        return f'''---
# Ansible site playbook — task {task_id}
# Generated by IaC Generator Agent

- name: Deploy application
  hosts: app_servers
  become: yes
  roles:
    - {roles_yaml}
'''

    def _ansible_hardening(self, constraints: List[str]) -> str:
        tasks = ['''---
# Hardening tasks — generated''']
        tasks.append('''
- name: Disable root SSH login
  lineinfile:
    path: /etc/ssh/sshd_config
    regexp: "^PermitRootLogin"
    line: "PermitRootLogin no"
  notify: restart sshd

- name: Set secure umask
  lineinfile:
    path: /etc/profile
    line: "umask 027"

- name: Enable UFW firewall
  ufw:
    state: enabled
    policy: deny''')
        if "network_isolation" in constraints:
            tasks.append('''
- name: Block all outbound except approved
  ufw:
    rule: deny
    direction: out
    to: any''')
        if "privilege_restriction" in constraints:
            tasks.append('''
- name: Remove SUID from dangerous binaries
  file:
    path: "{{ item }}"
    mode: "u-s"
  loop:
    - /usr/bin/su
    - /usr/bin/sudo''')
        return "\n".join(tasks)

    def _imperative_script(self, task_id: str, constraints: List[str]) -> str:
        return f'''#!/bin/bash
# Imperative deployment script — task {task_id}
set -euo pipefail

RG="rg-app-prod"
LOCATION="eastus"

echo "[1/5] Creating resource group..."
az group create --name "$RG" --location "$LOCATION" --tags task_id={task_id}

echo "[2/5] Creating VNet + NSG..."
az network vnet create --resource-group "$RG" --name vnet-app --address-prefix 10.0.0.0/16
az network nsg create --resource-group "$RG" --name nsg-app
az network nsg rule create --resource-group "$RG" --nsg-name nsg-app \\
  --name DenyAllInbound --priority 4096 --direction Inbound --access Deny \\
  --protocol "*" --source-address-prefixes "*" --destination-address-prefixes "*"

echo "[3/5] Creating subnet..."
az network vnet subnet create --resource-group "$RG" --vnet-name vnet-app \\
  --name snet-app --address-prefix 10.0.1.0/24 --nsg nsg-app

echo "[4/5] Deploying container..."
az container create --resource-group "$RG" --name aci-app \\
  --image "$APP_IMAGE" --cpu 0.5 --memory 1.5 \\
  --subnet snet-app --vnet vnet-app --restart-policy Never

echo "[5/5] Done."
'''